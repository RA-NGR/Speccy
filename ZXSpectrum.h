#pragma once

#include "Settings.h"
#include "Display.h"
//#include "ZXPeripherals.h"


class ZXSpectrum
{
	const uint16_t m_colorLookup[16] = { 0x0000, 0x1700, 0x00B8, 0x17B8, 0xE005, 0xF705, 0xE0BD, 0xF7BD,
										 0x0000, 0x1F00, 0x00F8, 0x1FF8, 0xE007, 0xFF07, 0xE0FF, 0xFFFF };
	typedef uint8_t BYTE;
	typedef uint16_t WORD;
	typedef uint32_t DWORD;
	typedef int8_t OFFSET;
	typedef union
	{
		struct { BYTE l, h; } b; // Little Endian
		WORD w;
	} PAIR;
	const BYTE m_halfcarryAddTable[8] = { 0x00, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10 };
	const BYTE m_halfcarrySubTable[8] = { 0x00, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10 };
	const BYTE m_overflowAddTable[8] = { 0x00, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x00 };
	const BYTE m_overflowSubTable[8] = { 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00 };
	const BYTE m_sz53Table[0x100] = {
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
		0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
		0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
		0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
		0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8,
		0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
		0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
		0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
		0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
		0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
		0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8,
		0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0, 0xA0,
		0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8
	};
	const BYTE m_parityTable[0x100] = {
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04
	};
	const BYTE m_sz53pTable[0x100] = {
		0x44, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x08, 0x0C, 0x0C, 0x08, 0x0C, 0x08, 0x08, 0x0C,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x0C, 0x08, 0x08, 0x0C, 0x08, 0x0C, 0x0C, 0x08,
		0x20, 0x24, 0x24, 0x20, 0x24, 0x20, 0x20, 0x24,
		0x2C, 0x28, 0x28, 0x2C, 0x28, 0x2C, 0x2C, 0x28,
		0x24, 0x20, 0x20, 0x24, 0x20, 0x24, 0x24, 0x20,
		0x28, 0x2C, 0x2C, 0x28, 0x2C, 0x28, 0x28, 0x2C,
		0x00, 0x04, 0x04, 0x00, 0x04, 0x00, 0x00, 0x04,
		0x0C, 0x08, 0x08, 0x0C, 0x08, 0x0C, 0x0C, 0x08,
		0x04, 0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x00,
		0x08, 0x0C, 0x0C, 0x08, 0x0C, 0x08, 0x08, 0x0C,
		0x24, 0x20, 0x20, 0x24, 0x20, 0x24, 0x24, 0x20,
		0x28, 0x2C, 0x2C, 0x28, 0x2C, 0x28, 0x28, 0x2C,
		0x20, 0x24, 0x24, 0x20, 0x24, 0x20, 0x20, 0x24,
		0x2C, 0x28, 0x28, 0x2C, 0x28, 0x2C, 0x2C, 0x28,
		0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
		0x8C, 0x88, 0x88, 0x8C, 0x88, 0x8C, 0x8C, 0x88,
		0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
		0x88, 0x8C, 0x8C, 0x88, 0x8C, 0x88, 0x88, 0x8C,
		0xA4, 0xA0, 0xA0, 0xA4, 0xA0, 0xA4, 0xA4, 0xA0,
		0xA8, 0xAC, 0xAC, 0xA8, 0xAC, 0xA8, 0xA8, 0xAC,
		0xA0, 0xA4, 0xA4, 0xA0, 0xA4, 0xA0, 0xA0, 0xA4,
		0xAC, 0xA8, 0xA8, 0xAC, 0xA8, 0xAC, 0xAC, 0xA8,
		0x84, 0x80, 0x80, 0x84, 0x80, 0x84, 0x84, 0x80,
		0x88, 0x8C, 0x8C, 0x88, 0x8C, 0x88, 0x88, 0x8C,
		0x80, 0x84, 0x84, 0x80, 0x84, 0x80, 0x80, 0x84,
		0x8C, 0x88, 0x88, 0x8C, 0x88, 0x8C, 0x8C, 0x88,
		0xA0, 0xA4, 0xA4, 0xA0, 0xA4, 0xA0, 0xA0, 0xA4,
		0xAC, 0xA8, 0xA8, 0xAC, 0xA8, 0xAC, 0xAC, 0xA8,
		0xA4, 0xA0, 0xA0, 0xA4, 0xA0, 0xA4, 0xA4, 0xA0,
		0xA8, 0xAC, 0xAC, 0xA8, 0xAC, 0xA8, 0xA8, 0xAC
	};
	struct Z80 {
		PAIR af, bc, de, hl;
		PAIR af_, bc_, de_, hl_;
		PAIR ix, iy;
		BYTE i;
		BYTE r;
		BYTE r7;
		PAIR sp, pc;
		PAIR memptr;
		int iff2_read;
		BYTE iff1, iff2, im;
		int halted;
		BYTE q;
		int32_t intEnabledAt;
		int32_t tCount;
	} m_Z80Processor;
	struct Tape
	{
		bool isTapeActive; // Tape running
		int  stateCycles; // CPU cycles per state
		int  statesCount; //  Number of states repeat
		BYTE tapeState; // Phase of tape (pilot, syncro etc.)
	} m_ZXTape;
	struct TapeStates
	{
		int stateCycles; // CPU cycles per state
		int statesCount; // Number of states repeat
	} m_tapeStates[5] = {
		{ 855, 2 },     // 0
		{ 1710, 2 },    // 1
		{ 2168, 4846 }, // Pilot
		{ 667, 1 },     // Sync HIGH
		{ 735, 1 }      // Sync LOW    
	};
	struct TAPData
	{
		uint16_t size;
		BYTE* data;
		uint32_t bit;
	} m_TAPSection;
	struct BorderColors
	{
		uint16_t x;
		uint8_t y;
		uint16_t color;
	} m_borderColors[BORDER_BUFFER_SIZE];
	uint8_t m_pbWIndex = 0;
	uint8_t m_pbRIndex = 0;
	uint16_t m_borderColor = m_colorLookup[7];
	uint8_t m_frameCounter = 0;
	uint8_t* m_pZXMemory;
	uint16_t* m_pScreenBuffer[2];
	uint8_t* m_pContendTable;
	bool m_initComplete = false;
	int16_t m_scanLine = -1;
	uint32_t m_emulationTime = 0;
	union PortFE
	{
		struct
		{
			uint8_t borderColor : 3;
			uint8_t tapeOut : 1;
			uint8_t soundOut : 1;
			uint8_t unused : 3;
		};
		uint8_t rawData;
	} m_outPortFE;
	BYTE m_inPortFE[9] = { 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF, 0x00 }; // 8 - kempston
	Display* m_pDisplayInstance;
	void drawLine(int posY);
	int8_t intZ80();
	void processTape();
	void writeMem(WORD address, BYTE data);
	BYTE readMem(WORD address);
	BYTE unattachedPort();
	BYTE readPort(WORD port);
	void writePort(WORD port, BYTE data);
	void stepCB(BYTE opcode);
	void stepED(BYTE opcpde);
	bool stepDD(BYTE opcode);
	bool stepFD(BYTE opcode);
	void stepXXCB(BYTE opcode);
	void stepZ80();
public:
	ZXSpectrum() {};
	~ZXSpectrum();
	bool init(Display* pDisplayInstance);
	void resetZ80();
	void loopZ80();
	uint32_t getEmulationTime() { return m_emulationTime; };
	BYTE getPortVal(uint16_t portNum) { return m_inPortFE[portNum]; };
	void setPortVal(uint16_t portNum, BYTE value) { m_inPortFE[portNum] = value; };
	void andPortVal(WORD portNum, BYTE value) { m_inPortFE[portNum] &= value; };
	void orPortVal(WORD portNum, BYTE value) { m_inPortFE[portNum] |= value; };
	void startTape(BYTE* pBuffer, uint32_t bufferSize);
	void stopTape() { m_ZXTape.isTapeActive = false; };
	bool tapeActive() { return m_ZXTape.isTapeActive; };
	void tape2X();
	void tape1X();
};